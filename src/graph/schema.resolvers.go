package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"LinkKrec/graph/loaders"
	"LinkKrec/graph/model"
	"LinkKrec/graph/util"
	query_builder "LinkKrec/querybuilder"
	"context"
	"fmt"
	"strconv"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.RegisterUserInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: RegisterUser - registerUser"))
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// UpdateUserProfile is the resolver for the updateUserProfile field.
func (r *mutationResolver) UpdateUserProfile(ctx context.Context, id string, input model.UpdateProfileInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUserProfile - updateUserProfile"))
}

// ManageConnection is the resolver for the manageConnection field.
func (r *mutationResolver) ManageConnection(ctx context.Context, userID string, connectedUserID string, action string) (*model.AskedConnection, error) {
	panic(fmt.Errorf("not implemented: ManageConnection - manageConnection"))
}

// NotifyProfileVisit is the resolver for the notifyProfileVisit field.
func (r *mutationResolver) NotifyProfileVisit(ctx context.Context, visitorID string, visitedUserID string) (*model.Notification, error) {
	panic(fmt.Errorf("not implemented: NotifyProfileVisit - notifyProfileVisit"))
}

// CreateVacancy is the resolver for the createVacancy field.
func (r *mutationResolver) CreateVacancy(ctx context.Context, employerID string, input model.CreateVacancyInput) (*model.Vacancy, error) {
	panic(fmt.Errorf("not implemented: CreateVacancy - createVacancy"))
}

// UpdateVacancy is the resolver for the updateVacancy field.
func (r *mutationResolver) UpdateVacancy(ctx context.Context, id string, input model.CreateVacancyInput) (*model.Vacancy, error) {
	panic(fmt.Errorf("not implemented: UpdateVacancy - updateVacancy"))
}

// DeleteVacancy is the resolver for the deleteVacancy field.
func (r *mutationResolver) DeleteVacancy(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteVacancy - deleteVacancy"))
}

// UpdateUserLookingForOpportunities is the resolver for the updateUserLookingForOpportunities field.
func (r *mutationResolver) UpdateUserLookingForOpportunities(ctx context.Context, userID string, looking bool) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUserLookingForOpportunities - updateUserLookingForOpportunities"))
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	return loaders.GetUser(ctx, id)
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, name *string, location *string, isEmployer *bool, skills []*string, lookingForOpportunities *bool) ([]*model.User, error) {
	q := query_builder.
		QueryBuilder().Select([]string{"id", "name", "email", "isEmployer", "location", "lookingForOpportunities"}).
		GroupConcat("skill", ", ", "skills", true).
		GroupConcat("connectionName", ", ", "connections", true).
		WhereSubject("user", "User").
		Where("Id", "id").
		Where("hasName", "name").
		Where("hasEmail", "email").
		Where("isEmployer", "isEmployer").
		Where("hasLocation", "location").
		Where("isLookingForOpportunities", "isLookingForOpportunities").
		Where("hasSkill", "skill").
		Where("hasConnection", "connection").
		WhereExtraction("connection", "Id", "connectionName").
		Bind("isLookingForOpportunities", "lookingForOpportunities")
	if name != nil {
		q.Filter("name", []string{*name}, query_builder.EQ)
	}
	if location != nil {
		q.Filter("location", []string{*location}, query_builder.EQ)
	}
	if isEmployer != nil {
		q.Filter("isEmployer", []string{strconv.FormatBool(*isEmployer)}, query_builder.EQ)
	}
	if len(skills) > 0 {
		convSkills := util.Map(skills, func(s *string) string {
			return fmt.Sprintf("\"%s\"", *s)
		})
		q.Filter("skill", convSkills, query_builder.IN)
	}
	if lookingForOpportunities != nil {
		q.Filter("isLookingForOpportunities", []string{strconv.FormatBool(*lookingForOpportunities)}, query_builder.EQ)
	}
	qs := q.GroupBy([]string{"id", "name", "email", "isEmployer", "location", "lookingForOpportunities"}).Build()

	res, err := r.Repo.Query(qs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	users := make([]*model.User, 0)
	for _, user := range res.Solutions() {
		obj, err := util.MapRdfUserToGQL(user)
		if err != nil {
			return nil, err
		}
		users = append(users, obj)
	}
	return users, nil
}

// GetVacancies is the resolver for the getVacancies field.
func (r *queryResolver) GetVacancies(ctx context.Context, title *string, location *string, requiredEducation *model.DegreeType, status *bool) ([]*model.Vacancy, error) {
	q := query_builder.
		QueryBuilder().Select([]string{"id", "title", "description", "location", "postedBy", "startDate", "endDate", "status", "education"}).
		GroupConcat("experienceType", ", ", "experienceTypes", true).
		GroupConcat("experienceDuration", ", ", "experienceDurations", true).
		WhereSubject("vacancy", "Vacancy").
		Where("Id", "id").
		Where("vacancyTitle", "title").
		Where("vacancyDescription", "description").
		Where("vacancyLocation", "location").
		//Where("postedBy", "postedBy").
		Where("vacancyStartDate", "startDate").
		Where("vacancyEndDate", "endDate").
		Where("vacancyStatus", "status").
		Where("requiredEducation", "education").
		Where("requiredExperienceType", "experienceType").
		Where("requiredExperienceDuration", "experienceDuration")
	if title != nil {
		q.Filter("name", []string{*title}, query_builder.EQ)
	}
	if location != nil {
		q.Filter("location", []string{*location}, query_builder.EQ)
	}
	if requiredEducation != nil {
		q.Filter("requiredEducation", []string{string(*requiredEducation)}, query_builder.EQ)
	}
	if status != nil {
		q.Filter("status", []string{strconv.FormatBool(*status)}, query_builder.EQ)
	}
	qs := q.GroupBy([]string{"id", "title", "description", "location", "postedBy", "startDate", "endDate", "status", "education"}).Build()

	fmt.Println(qs)
	res, err := r.Repo.Query(qs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	vacancies := make([]*model.Vacancy, 0)
	for _, user := range res.Solutions() {
		obj, err := util.MapRdfVacancyToGQL(user)
		if err != nil {
			return nil, err
		}
		vacancies = append(vacancies, obj)
		fmt.Println("obj:", obj)
	}
	return vacancies, nil
}

// GetVacancy is the resolver for the getVacancy field.
func (r *queryResolver) GetVacancy(ctx context.Context, id string) (*model.Vacancy, error) {
	return loaders.GetVacancy(ctx, id)
}

// GetEmployers is the resolver for the getEmployers field.
func (r *queryResolver) GetEmployers(ctx context.Context, name *string, location *string) ([]*model.Employer, error) {
	panic(fmt.Errorf("not implemented: GetEmployers - getEmployers"))
}

// GetEmployer is the resolver for the getEmployer field.
func (r *queryResolver) GetEmployer(ctx context.Context, id string) (*model.Employer, error) {
	panic(fmt.Errorf("not implemented: GetEmployer - getEmployer"))
}

// GetNotifications is the resolver for the getNotifications field.
func (r *queryResolver) GetNotifications(ctx context.Context, userID string, since *string) ([]*model.Notification, error) {
	panic(fmt.Errorf("not implemented: GetNotifications - getNotifications"))
}

// GetConnectionRequests is the resolver for the getConnectionRequests field.
func (r *queryResolver) GetConnectionRequests(ctx context.Context, userID string, status *bool) ([]*model.AskedConnection, error) {
	panic(fmt.Errorf("not implemented: GetConnectionRequests - getConnectionRequests"))
}

// NewConnectionRequest is the resolver for the newConnectionRequest field.
func (r *subscriptionResolver) NewConnectionRequest(ctx context.Context, forUserID string) (<-chan *model.AskedConnection, error) {
	panic(fmt.Errorf("not implemented: NewConnectionRequest - newConnectionRequest"))
}

// ConnectionRequestStatusUpdate is the resolver for the connectionRequestStatusUpdate field.
func (r *subscriptionResolver) ConnectionRequestStatusUpdate(ctx context.Context, forUserID string) (<-chan *model.AskedConnection, error) {
	panic(fmt.Errorf("not implemented: ConnectionRequestStatusUpdate - connectionRequestStatusUpdate"))
}

// NewMatchingVacancy is the resolver for the newMatchingVacancy field.
func (r *subscriptionResolver) NewMatchingVacancy(ctx context.Context, userID string) (<-chan *model.Vacancy, error) {
	panic(fmt.Errorf("not implemented: NewMatchingVacancy - newMatchingVacancy"))
}

// NewNotification is the resolver for the newNotification field.
func (r *subscriptionResolver) NewNotification(ctx context.Context, forUserID string) (<-chan *model.Notification, error) {
	panic(fmt.Errorf("not implemented: NewNotification - newNotification"))
}

// Connections is the resolver for the connections field.
func (r *userResolver) Connections(ctx context.Context, obj *model.User) ([]*model.User, error) {
	ids := util.Map(obj.Connections, func(u *model.User) string {
		return u.ID
	})
	return loaders.GetUsers(ctx, ids)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
