package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"LinkKrec/gisco"
	"LinkKrec/graph/loaders"
	"LinkKrec/graph/model"
	"LinkKrec/graph/util"
	query_builder "LinkKrec/querybuilder"
	"LinkKrec/usersession"
	"context"
	"fmt"
	"log"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/knakk/rdf"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Location is the resolver for the location field.
func (r *companyResolver) Location(ctx context.Context, obj *model.Company) (*model.Location, error) {
	return loaders.GetLocation(ctx, obj.Location.ID)
}

// Vacancies is the resolver for the vacancies field.
func (r *companyResolver) Vacancies(ctx context.Context, obj *model.Company) ([]*model.Vacancy, error) {
	ids := util.Map(obj.Vacancies, func(v *model.Vacancy) string {
		return v.ID
	})
	return loaders.GetVacancies(ctx, ids)
}

// Employees is the resolver for the employees field.
func (r *companyResolver) Employees(ctx context.Context, obj *model.Company) ([]*model.User, error) {
	ids := util.Map(obj.Employees, func(u *model.User) string {
		return u.ID
	})
	return loaders.GetUsers(ctx, ids)
}

// FromUser is the resolver for the fromUser field.
func (r *connectionRequestResolver) FromUser(ctx context.Context, obj *model.ConnectionRequest) (*model.User, error) {
	return loaders.GetUser(ctx, obj.FromUser.ID)
}

// ConnectedToUser is the resolver for the connectedToUser field.
func (r *connectionRequestResolver) ConnectedToUser(ctx context.Context, obj *model.ConnectionRequest) (*model.User, error) {
	return loaders.GetUser(ctx, obj.ConnectedToUser.ID)
}

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.RegisterUserInput) (*model.User, error) {
	panic("RegisterUser is deprecated and not supported in any way, please go through /auth/`provider`")
}

// CompleteUserProfile is the resolver for the completeUserProfile field.
func (r *mutationResolver) CompleteUserProfile(ctx context.Context, id string, input model.UpdateProfileInput) (*model.User, error) {
	sess_info := usersession.For(ctx)

	if sess_info.Id != id {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't complete another users account\nYour Id is: %s", sess_info.Id)
	}

	// first check if user already did this
	if sess_info.IsComplete {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Account already completed, please use `UpdateUserProfile`")
	}

	coordinates := gisco.CoordinatesFromAddress(input.Country, input.City, &input.Streetname, &input.Housenumber)
	if coordinates == nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Invalid address")
	}

	locationId := uuid.New().String()

	hasSkills := ""
	for _, skill := range input.Skills {
		hasSkills += fmt.Sprintf("\nlr:hasSkill esco_skill:%s ;", skill)
	}

	insertExperienceBluePrint := `
			PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
			PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
			PREFIX lr: <http://linkrec.example.org/schema#> 
			PREFIX esco: <http://data.europa.eu/esco/model#>
			PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
			PREFIX esco_occupation: <http://data.europa.eu/esco/occupation/>

			INSERT DATA {
				%s
			}
	`
	experienceInserts := ""
	var experienceEntries []string
	for _, exp := range input.Experience {
		expId := uuid.New().String()
		experienceInserts += fmt.Sprintf(`
			lr:Experience%s a lr:Experience ;
				lr:Id "%s" ;
				lr:escoOccup esco_occupation:%s ;
				lr:durationInMonths %d .

			`, expId, expId, exp.ID, exp.DurationInMonths)
		experienceEntries = append(experienceEntries, fmt.Sprintf("\nlr:hasExperience lr:Experience%s ;", expId))
	}
	insertExp := fmt.Sprintf(insertExperienceBluePrint, experienceInserts)
	err := r.UpdateRepo.Update(insertExp)
	if err != nil {
		return nil, fmt.Errorf("failed to insert experience: %v", err)
	}

	insertEducation := `
			PREFIX lr: <http://linkrec.example.org/schema#> 
			PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
			PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
			PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 

			INSERT DATA {
				lr:EducationEntry%s a lr:EducationEntry ;
					lr:Id "%s" ;
					lr:extraInfo "%s" ;
					lr:institutionName "%s" ;
					lr:degreeType lr:%s ;
					lr:degreeField lr:%s ;
					lr:startDate "%s"^^xsd:dateTime ;
					lr:endDate "%s"^^xsd:dateTime  .
			}
		`
	educationEntries := ""
	for _, edu := range input.Education {
		if edu == nil {
			continue
		}
		uuid := uuid.New().String()
		start := time.Time(edu.From)
		end := time.Time(edu.Till)
		extra_info := ""
		if edu.ExtraInfo != nil {
			extra_info = *edu.ExtraInfo
		}
		update := fmt.Sprintf(insertEducation, uuid, uuid, extra_info, edu.Institution, edu.Degree, edu.Field, start.Format(time.DateOnly), end.Format(time.DateOnly))
		err := r.UpdateRepo.Update(update)
		if err != nil {
			return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't insert %s education because: %s", uuid, err)
		}
		educationEntries += fmt.Sprintf("\nlr:hasEducation lr:EducationEntry%s ;", uuid)

	}

	updateUser := fmt.Sprintf(`
			PREFIX lr: <http://linkrec.example.org/schema#> 
			PREFIX schema: <http://schema.org/> 
			PREFIX foaf: <http://xmlns.com/foaf/0.1/> 
			PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
			PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
			PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
			PREFIX esco: <http://data.europa.eu/esco/model#>
			PREFIX esco_skill: <http://data.europa.eu/esco/skill/>
			PREFIX esco_occupation: <http://data.europa.eu/esco/occupation/>

			DELETE {
				?user a lr:User ;
					lr:isProfileComplete false .
			}
			INSERT{
				?user a lr:User ;
					%s
					%s
					%s
					foaf:based_near lr:Location%s ;
					lr:isLookingForOpportunities %v ;
					lr:isProfileComplete true  .
			}
			WHERE {
			  ?user a lr:User ;
		          lr:Id "%s" .
			}

		`, hasSkills, educationEntries, strings.Join(experienceEntries, ""), locationId, input.IsLookingForOpportunities, sess_info.Id)

	// update user is more likely to crash, and because transactions are a fucking pain
	// im doing this insert later, sparql only needs the id so fuck that
	locationInsert := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>

		INSERT DATA {
			lr:Location%s a lr:Location ;
				lr:Id "%s" ;
				lr:inCountry "%s" ;
				lr:inCity "%s" ;
				lr:inStreet "%s" ;
				lr:houseNumber "%s" ;
				lr:longitude "%.6f" ;
				lr:latitude "%.6f" .
		}
		`, locationId, locationId, input.Country, input.City, input.Streetname, input.Housenumber, coordinates.Long, coordinates.Lat)

	err = r.UpdateRepo.Update(locationInsert)
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't insert location %s because: %s", locationId, err)
	}

	err = r.UpdateRepo.Update(updateUser)
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update user %s because: %s", sess_info.Id, err)
	}

	// remember...
	g := ctx.Value("ginCtx").(*gin.Context)
	session, _ := r.Store.Get(g.Request, "user-session")
	session.Values[usersession.SessionInfoKey].(*usersession.UserSessionInfo).IsComplete = true
	if err := session.Save(g.Request, g.Writer); err != nil {
		// Log or handle session save error if needed
		log.Printf("Error saving session: %v", err)
	}
	return loaders.GetUser(ctx, sess_info.Id)
}

// UpdateUserProfile is the resolver for the updateUserProfile field.
func (r *mutationResolver) UpdateUserProfile(ctx context.Context, id string, input model.UpdateProfileInput) (*model.User, error) {
	sess_info := usersession.For(ctx)

	if sess_info.Id != id {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update another users account\nYour Id is: %s", sess_info.Id)
	}

	// first check if user already did this

	if !sess_info.IsComplete {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update incomplete profile, please use `CompleteUserProfile`")
	}

	coordinates := gisco.CoordinatesFromAddress(input.Country, input.City, &input.Streetname, &input.Housenumber)
	if coordinates == nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Invalid address")
	}

	locationId := uuid.New().String()

	hasSkills := ""
	for _, skill := range input.Skills {
		hasSkills += fmt.Sprintf("\nlr:hasSkill esco_skill:%s ;", skill)
	}

	insertEducation := `
			PREFIX lr: <http://linkrec.example.org/schema#> 
			PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
			PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
			PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 

			INSERT DATA {
				lr:EducationEntry%s a lr:EducationEntry ;
					lr:Id "%s" ;
					lr:extraInfo "%s" ;
					lr:institutionName "%s" ;
					lr:degreeType lr:%s ;
					lr:degreeField lr:%s ;
					lr:startDate "%s"^^xsd:dateTime ;
					lr:endDate "%s"^^xsd:dateTime  .
			}
		`
	educationEntries := ""
	for _, edu := range input.Education {
		uuid := uuid.New().String()
		start := time.Time(edu.From)
		end := time.Time(edu.Till)
		extra_info := ""
		if edu.ExtraInfo != nil {
			extra_info = *edu.ExtraInfo
		}
		update := fmt.Sprintf(insertEducation, uuid, uuid, extra_info, edu.Institution, edu.Degree, edu.Field, start.Format(time.DateOnly), end.Format(time.DateOnly))
		fmt.Println(update)
		err := r.UpdateRepo.Update(update)
		if err != nil {
			return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't insert %s education because: %s", uuid, err)
		}
		educationEntries += fmt.Sprintf("\nlr:hasEducation lr:EducationEntry%s ;", uuid)

	}

	insertExperienceBluePrint := `
			PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
			PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
			PREFIX lr: <http://linkrec.example.org/schema#> 
			PREFIX esco: <http://data.europa.eu/esco/model#>
			PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
			PREFIX esco_occupation: <http://data.europa.eu/esco/occupation/>

			INSERT DATA {
				%s
			}
	`
	experienceInserts := ""
	var experienceEntries []string
	for _, exp := range input.Experience {
		expId := uuid.New().String()
		experienceInserts += fmt.Sprintf(`
			lr:Experience%s a lr:Experience ;
				lr:Id "%s" ;
				lr:escoOccup esco_occupation:%s ;
				lr:durationInMonths %d .

			`, expId, expId, exp.ID, exp.DurationInMonths)
		experienceEntries = append(experienceEntries, fmt.Sprintf("\nlr:hasExperience lr:Experience%s ;", expId))
	}
	insertExp := fmt.Sprintf(insertExperienceBluePrint, experienceInserts)
	err := r.UpdateRepo.Update(insertExp)
	if err != nil {
		return nil, fmt.Errorf("failed to insert experience: %v", err)
	}

	updateUser := fmt.Sprintf(`
			PREFIX lr: <http://linkrec.example.org/schema#> 
			PREFIX schema: <http://schema.org/> 
			PREFIX foaf: <http://xmlns.com/foaf/0.1/> 
			PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
			PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
			PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
			PREFIX esco: <http://data.europa.eu/esco/model#>
			PREFIX esco_skill: <http://data.europa.eu/esco/skill/>

			DELETE {
				?user a lr:User ;
					lr:hasSkill ?oldSkill;
					lr:isLookingForOpportunities ?oldOpts ;
					lr:hasEducation ?oldEdu ;
					lr:hasExperience ?oldExpr .

				?oldEdu ?eduP ?eduO .
				?oldExpr ?exprP ?exprO .
			}
			INSERT{
				?user a lr:User ;
					%s
					%s
					%s
					lr:isLookingForOpportunities %v ;
			}
			WHERE {
			  ?user a lr:User ;
		          lr:Id "%s" ;
				  lr:isLookingForOpportunities ?oldOpts ;

			  OPTIONAL{	  	
			  	  ?user a lr:User ;
			          lr:hasSkill ?oldSkill .
			  }

		      OPTIONAL {
			      ?user lr:hasEducation ?oldEdu .
			      ?oldEdu ?eduP ?eduO .
			  }

			  OPTIONAL {
			  	?user lr:hasExperience ?oldExpr .
			  	?oldExpr ?exprP ?exprO .
			  }
			}

		`, hasSkills, educationEntries, strings.Join(experienceEntries, ""), input.IsLookingForOpportunities, sess_info.Id)

	// delete the old values and insert the new
	locationInsert := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX foaf: <http://xmlns.com/foaf/0.1/> 

		
		DELETE{
			?loc a lr:Location ;
				lr:inCountry ?oldCountry ;
				lr:inCity ?oldCity ;
				lr:inStreet ?oldStreet ;
				lr:houseNumber ?oldNumber ;
				lr:longitude ?oldLong ;
				lr:latitude ?oldLat .
		}
		INSERT {
			?loc a lr:Location ;
				lr:inCountry "%s" ;
				lr:inCity "%s" ;
				lr:inStreet "%s" ;
				lr:houseNumber "%s" ;
				lr:longitude "%.6f" ;
				lr:latitude "%.6f" .
		}
		WHERE {
			?user a lr:User ;
				lr:Id "%s" ;
				foaf:based_near ?loc .

			?loc a lr:Location ;
				lr:inCountry ?oldCountry ;
				lr:inCity ?oldCity ;
				lr:inStreet ?oldStreet ;
				lr:houseNumber ?oldNumber ;
				lr:longitude ?oldLong ;
				lr:latitude ?oldLat .
		}
		`, input.Country, input.City, input.Streetname, input.Housenumber, coordinates.Long, coordinates.Lat, sess_info.Id)

	err = r.UpdateRepo.Update(locationInsert)
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't insert location %s because: %s", locationId, err)
	}

	err = r.UpdateRepo.Update(updateUser)
	fmt.Println(updateUser)
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update user %s because: %s", sess_info.Id, err)
	}

	return loaders.GetUser(ctx, sess_info.Id)
}

// AddConnectionRequest is the resolver for the addConnectionRequest field.
func (r *mutationResolver) AddConnectionRequest(ctx context.Context, fromUserID string, connectedToUserID string) (*model.ConnectionRequest, error) {
	requestID := uuid.New().String()

	q := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>

		INSERT {
		  lr:connectionRequest%s a lr:ConnectionRequest ;
		      lr:Id "%s" ;
		      lr:fromUser ?fromUser ;
		      lr:connectedToUser ?toUser ;
		      lr:requestStatus false .
		}
		WHERE {
		  ?fromUser a lr:User ;
		            lr:Id "%s" .
		  ?toUser a lr:User ;
		          lr:Id "%s" .
		}
		`, requestID, requestID, fromUserID, connectedToUserID)

	err := r.UpdateRepo.Update(q)
	if err != nil {
		return nil, err
	}
	fmt.Println("err:", err)

	// If the query was successful, return the updated user
	return loaders.GetConnectionRequest(ctx, requestID)
}

// SetConnectionRequestStatusFalse is the resolver for the setConnectionRequestStatusFalse field.
func (r *mutationResolver) SetConnectionRequestStatusFalse(ctx context.Context, id string) (*model.ConnectionRequest, error) {
	q := fmt.Sprintf(`
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        PREFIX lr: <http://linkrec.example.org/schema#>
        PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        DELETE {
            ?connectionRequest lr:status ?status .
        }
        INSERT {
            ?connectionRequest lr:status false .
        }
        WHERE {
            ?connectionRequest a lr:ConnectionRequest ;
                               lr:Id "%s" ;
                               lr:status ?status .
        }
    `, id)

	err := r.UpdateRepo.Update(q)
	if err != nil {
		return nil, err
	}

	return loaders.GetConnectionRequest(ctx, id)
}

// NotifyProfileVisit is the resolver for the notifyProfileVisit field.
func (r *mutationResolver) NotifyProfileVisit(ctx context.Context, visitorID string, visitedUserID string) (*model.Notification, error) {
	notificationID := uuid.New().String()

	visitedByUser, err := loaders.GetUser(ctx, visitorID)
	if err != nil {
		return nil, err
	}

	q := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

		INSERT DATA {
		  lr:notification%s a lr:Notification ;
		      lr:Id "%s" ;
		      lr:notificationTitle "Profile Visit" ;
		      lr:notificationMessage "Your profile has been visited by %s" ;
		      lr:forUser lr:User%s ;
		      lr:notificationCreatedAt "%s"^^xsd:dateTime .
		}
	`, notificationID, notificationID, visitorID, visitedByUser.Name, time.Now())

	updErr := r.UpdateRepo.Update(q)
	if updErr != nil {
		return nil, updErr
	}

	return loaders.GetNotification(ctx, notificationID)
}

// CreateVacancy is the resolver for the createVacancy field.
func (r *mutationResolver) CreateVacancy(ctx context.Context, companyID string, input model.CreateVacancyInput) (*model.Vacancy, error) {
	// usersess := usersession.For(ctx)
	// if !slices.Contains(usersess.CompanyIds, companyID) {
	// 	return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't create vacancy for other company")
	// }
	coordinates := gisco.CoordinatesFromAddress(input.Location.Country, input.Location.City, &input.Location.Street, &input.Location.HouseNumber)
	if coordinates == nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Invalid address")
	}

	locationId := uuid.New().String()

	locationInsert := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX foaf: <http://xmlns.com/foaf/0.1/>
		PREFIX esco_skill: <http://data.europa.eu/esco/skill/>

		INSERT DATA {
			lr:Location%s a lr:Location ;
				lr:Id "%s" ;
				lr:inCountry "%s" ;
				lr:inCity "%s" ;
				lr:inStreet "%s" ;
				lr:houseNumber "%s" ;
				lr:longitude "%.6f" ;
				lr:latitude "%.6f" .
		}
	`, locationId, locationId, input.Location.Country, input.Location.City, input.Location.Street, input.Location.HouseNumber, coordinates.Long, coordinates.Lat)
	err := r.UpdateRepo.Update(locationInsert)
	if err != nil {
		return nil, err
	}

	insertExperienceBluePrint := `
			PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
			PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
			PREFIX lr: <http://linkrec.example.org/schema#> 
			PREFIX esco: <http://data.europa.eu/esco/model#>
			PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
			PREFIX esco_occupation: <http://data.europa.eu/esco/occupation/>

			INSERT DATA {
				%s
			}
	`
	experienceInserts := ""
	var experienceEntries []string
	for _, exp := range input.RequiredExperience {
		expId := uuid.New().String()
		experienceInserts += fmt.Sprintf(`
			lr:Experience%s a lr:Experience ;
				lr:Id "%s" ;
				lr:escoOccup esco_occupation:%s ;
				lr:durationInMonths %d .
			`, expId, expId, exp.ID, exp.DurationInMonths)
		experienceEntries = append(experienceEntries, fmt.Sprintf("; \nlr:requiredExperience lr:Experience%s", expId))
	}
	insertExp := fmt.Sprintf(insertExperienceBluePrint, experienceInserts)

	err = r.UpdateRepo.Update(insertExp)
	if err != nil {
		return nil, fmt.Errorf("failed to insert experience: %v", err)
	}

	vacancyID := uuid.New().String()
	var skillQueries = ""
	for _, skill := range input.RequiredSkills {
		skillQueries += fmt.Sprintf(" ;\nlr:requiredSkill esco_skill:%s", *skill)
	}
	skillQueries += " .\n"

	q := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
		PREFIX foaf: <http://xmlns.com/foaf/0.1/>
		PREFIX esco_skill: <http://data.europa.eu/esco/skill/>

		INSERT DATA {
			lr:Vacancy%s a lr:Vacancy ;
				lr:Id "%s" ;
				lr:vacancyTitle "%s" ;
				lr:vacancyDescription "%s" ;
				foaf:based_near lr:Location%s ;
				lr:postedBy lr:Company%s ;
				lr:vacancyStartDate "%s"^^xsd:date ;
				lr:vacancyEndDate "%s"^^xsd:date ;
				lr:vacancyStatus %t;
				lr:requiredDegreeType lr:%s ;
				lr:requiredDegreeField lr:%s 
				%s
				%s 

			lr:Company%s lr:hasVacancy lr:Vacancy%s
		}
		`, vacancyID, vacancyID, input.Title, input.Description, locationId,
		companyID, input.StartDate, input.EndDate, input.Status, input.RequiredDegreeType,
		input.RequiredDegreeField, strings.Join(experienceEntries, ""), skillQueries, companyID, vacancyID)

	fmt.Println(q)
	err = r.UpdateRepo.Update(q)
	if err != nil {
		return nil, err
	}

	// If the query was successful, return the updated user
	return loaders.GetVacancy(ctx, vacancyID)
}

// UpdateVacancy is the resolver for the updateVacancy field.
func (r *mutationResolver) UpdateVacancy(ctx context.Context, id string, input model.UpdateVacancyInput) (*model.Vacancy, error) {
	usersess := usersession.For(ctx)
	if !slices.Contains(usersess.CompanyIds, id) {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update vacancy of not owned company")
	}
	var deleteParts, insertParts string

	// Conditionally add fields to the DELETE/INSERT sections
	if input.Title != nil {
		deleteParts += "?vacancy lr:vacancyTitle ?oldTitle .\n"
		insertParts += fmt.Sprintf("?vacancy lr:vacancyTitle \"%s\" .\n", *input.Title)
	}
	if input.Description != nil {
		deleteParts += "?vacancy lr:vacancyDescription ?oldDescription .\n"
		insertParts += fmt.Sprintf("?vacancy lr:vacancyDescription \"%s\" .\n", *input.Description)
	}
	if input.StartDate != nil {
		deleteParts += "?vacancy lr:vacancyStartDate ?oldStartDate .\n"
		insertParts += fmt.Sprintf("?vacancy lr:vacancyStartDate \"%s\"^^xsd:date .\n", *input.StartDate)
	}
	if input.EndDate != nil {
		deleteParts += "?vacancy lr:vacancyEndDate ?oldEndDate .\n"
		insertParts += fmt.Sprintf("?vacancy lr:vacancyEndDate \"%s\"^^xsd:date .\n", *input.EndDate)
	}
	if input.RequiredDegreeType != nil {
		deleteParts += "?vacancy lr:requiredDegreeType ?oldDegreeType .\n"
		insertParts += fmt.Sprintf("?vacancy lr:requiredDegreeType lr:%s .\n", *input.RequiredDegreeType)
	}
	if input.RequiredDegreeField != nil {
		deleteParts += "?vacancy lr:requiredDegreeField ?oldDegreeField .\n"
		insertParts += fmt.Sprintf("?vacancy lr:requiredDegreeField lr:%s .\n", *input.RequiredDegreeField)
	}
	// check if the status is provided
	if input.Status != nil {
		deleteParts += "?vacancy lr:vacancyStatus ?oldStatus .\n"
		insertParts += fmt.Sprintf("?vacancy lr:vacancyStatus %t .\n", *input.Status)
	}
	if len(input.RequiredSkills) != 0 {
		deleteParts += "?vacancy lr:requiredSkill ?oldSkill .\n"
		for _, skill := range input.RequiredSkills {
			insertParts += fmt.Sprintf("?vacancy lr:requiredSkill esco_skill:%s .\n", *skill)
		}
	}

	// If no fields are provided, return an error
	if deleteParts == "" && insertParts == "" {
		return nil, fmt.Errorf("no fields provided for update")
	}

	coordinates := gisco.CoordinatesFromAddress(input.Location.Country, input.Location.City, &input.Location.Street, &input.Location.HouseNumber)
	if coordinates == nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Invalid address")
	}
	// delete the old values and insert the new
	locationInsert := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX foaf: <http://xmlns.com/foaf/0.1/> 
		
		DELETE{
			?loc a lr:Location ;
				lr:inCountry ?oldCountry ;
				lr:inCity ?oldCity ;
				lr:inStreet ?oldStreet ;
				lr:houseNumber ?oldNumber ;
				lr:longitude ?oldLong ;
				lr:latitude ?oldLat .
		}
		INSERT {
			?loc a lr:Location ;
				lr:inCountry "%s" ;
				lr:inCity "%s" ;
				lr:inStreet "%s" ;
				lr:houseNumber "%s" ;
				lr:longitude "%.6f" ;
				lr:latitude "%.6f" .
		}
		WHERE {
			?vac a lr:Vacancy ;
				lr:Id "%s" ;
				foaf:based_near ?loc .

			?loc a lr:Location ;
				lr:inCountry ?oldCountry ;
				lr:inCity ?oldCity ;
				lr:inStreet ?oldStreet ;
				lr:houseNumber ?oldNumber ;
				lr:longitude ?oldLong ;
				lr:latitude ?oldLat .
		}
		`, input.Location.Country, input.Location.City, input.Location.Street, input.Location.HouseNumber, coordinates.Long, coordinates.Lat, id)

	err := r.UpdateRepo.Update(locationInsert)
	if err != nil {
		return nil, err
	}

	// Construct the full SPARQL query
	q := fmt.Sprintf(`
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        PREFIX lr: <http://linkrec.example.org/schema#>
        PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
		PREFIX esco_skill: <http://data.europa.eu/esco/skill/>
		PREFIX foaf: <http://xmlns.com/foaf/0.1/> 

        DELETE {
            %s
        }
        INSERT {
            %s
        }
        WHERE {
            ?vacancy a lr:Vacancy ;
				lr:Id "%s" .
            %s
        }
    `, deleteParts, insertParts, id, deleteParts)
	fmt.Println(q)

	err = r.UpdateRepo.Update(q)
	if err != nil {
		return nil, err
	}
	return loaders.GetVacancy(ctx, id)
}

// DeleteVacancy is the resolver for the deleteVacancy field.
func (r *mutationResolver) DeleteVacancy(ctx context.Context, id string) (*bool, error) {
	usersess := usersession.For(ctx)
	if !slices.Contains(usersess.CompanyIds, id) {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't create vacancy for other company")
	}
	q := fmt.Sprintf(`
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
		
		DELETE {
          ?vacancy ?p ?o .
          ?location ?lp ?lo .
        }
        WHERE {
          ?vacancy a lr:Vacancy ;
                   lr:Id "%s" ;
                   ?p ?o .
        }
	`, id)

	err := r.UpdateRepo.Update(q)
	if err != nil {
		succes := false
		return &succes, err
	}

	success := true
	return &success, nil
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input model.CreateCompanyInput) (*model.Company, error) {
	usersess := usersession.For(ctx)
	companyID := uuid.New().String()
	locationID := uuid.New().String() // Unique ID for the company location

	coordinates := gisco.CoordinatesFromAddress(input.Location.Country, input.Location.City, &input.Location.Street, &input.Location.HouseNumber)
	if coordinates == nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Invalid address")
	}

	locationQuery := fmt.Sprintf(`
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        INSERT DATA {
            lr:location%s a lr:Location ;
                lr:Id "%s" ;
                lr:inCountry "%s" ;
                lr:inCity "%s" ;
                lr:inStreet "%s" ;
                lr:houseNumber "%s" ;
				lr:longitude "%.6f" ;
				lr:latitude "%.6f" .
        }
    `,
		locationID, locationID, input.Location.Country, input.Location.City, input.Location.Street, input.Location.HouseNumber, coordinates.Long, coordinates.Lat)

	if err := r.UpdateRepo.Update(locationQuery); err != nil {
		return nil, fmt.Errorf("failed to create location: %w", err)
	}

	companyQuery := fmt.Sprintf(`
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        INSERT DATA {
            lr:Company%s a lr:Company ;
                lr:Id "%s" ;
                lr:companyName "%s" ;
                lr:companyEmail "%s" ;
                lr:companyLocation lr:location%s .

            lr:User%s lr:hasCompany lr:Company%s .
        }
    `,
		companyID, companyID, input.Name, input.Email, locationID, usersess.Id, companyID,
	)

	if err := r.UpdateRepo.Update(companyQuery); err != nil {
		return nil, fmt.Errorf("failed to create company: %w", err)
	}

	// remember
	g := ctx.Value("ginCtx").(*gin.Context)
	session, _ := r.Store.Get(g.Request, "user-session")
	sessInfo := session.Values[usersession.SessionInfoKey].(*usersession.UserSessionInfo)
	sessInfo.CompanyIds = append(sessInfo.CompanyIds, companyID)
	if err := session.Save(g.Request, g.Writer); err != nil {
		// Log or handle session save error if needed
		log.Printf("Error saving session: %v", err)
	}

	return loaders.GetCompany(ctx, companyID)
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, id string, input model.UpdateCompanyInput) (*model.Company, error) {
	if !slices.Contains(usersession.For(ctx).CompanyIds, id) {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't Update non owned company")
	}

	updateQueries := ""

	if input.Name != nil {
		updateQueries += fmt.Sprintf(`
            DELETE { lr:company%s lr:companyName ?oldName. }
            INSERT { lr:company%s lr:companyName "%s". }
            WHERE { lr:company%s lr:companyName ?oldName. }
        `, id, id, *input.Name, id)
	}

	if input.Email != nil {
		updateQueries += fmt.Sprintf(`
            DELETE { lr:company%s lr:companyEmail ?oldEmail. }
            INSERT { lr:company%s lr:companyEmail "%s". }
            WHERE { lr:company%s lr:companyEmail ?oldEmail. }
        `, id, id, *input.Email, id)
	}

	if input.Location != nil {
		locationID := uuid.New().String() // Generate a new location ID.
		updateQueries += fmt.Sprintf(`
            DELETE {
                lr:company%s lr:companyLocation ?oldLocation.
                ?oldLocation ?p ?o.
            }
            INSERT {
                lr:company%s lr:companyLocation lr:location%s.
                lr:location%s lr:country "%s";
                      lr:city "%s";
                      lr:street "%s";
                      lr:houseNumber "%s".
            }
            WHERE {
                lr:company%s lr:companyLocation ?oldLocation.
                ?oldLocation ?p ?o.
            }
        `, id, id, locationID, locationID,
			input.Location.Country, input.Location.City, input.Location.Street, input.Location.HouseNumber, id)
	}

	if err := r.UpdateRepo.Update(updateQueries); err != nil {
		return nil, fmt.Errorf("failed to update company: %w", err)
	}

	return loaders.GetCompany(ctx, id)
}

// DeleteCompany is the resolver for the deleteCompany field.
func (r *mutationResolver) DeleteCompany(ctx context.Context, id string) (*bool, error) {
	if !slices.Contains(usersession.For(ctx).CompanyIds, id) {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't Delete non owned company")
	}

	deleteVacanciesQuery := fmt.Sprintf(`
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        DELETE {
            ?vacancy ?p ?o .
            ?location ?lp ?lo .
        }
        WHERE {
            ?vacancy a lr:Vacancy ;
                     lr:postedBy lr:company%s ;
                     lr:vacancyLocation ?location .
            ?vacancy ?p ?o .
            ?location ?lp ?lo .
        }
    `, id)

	if err := r.UpdateRepo.Update(deleteVacanciesQuery); err != nil {
		return nil, fmt.Errorf("failed to delete vacancies for company %s: %w", id, err)
	}

	// Step 2: Delete the location of the company
	deleteLocationQuery := fmt.Sprintf(`
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        DELETE {
            ?location ?p ?o .
        }
        WHERE {
            lr:company%s lr:companyLocation ?location .
            ?location ?p ?o .
        }
    `, id)

	if err := r.UpdateRepo.Update(deleteLocationQuery); err != nil {
		return nil, fmt.Errorf("failed to delete location for company %s: %w", id, err)
	}

	// Step 3: Delete the company
	deleteCompanyQuery := fmt.Sprintf(`
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        DELETE {
            lr:company%s ?p ?o .
        }
        WHERE {
            lr:company%s ?p ?o .
        }
    `, id, id)

	if err := r.UpdateRepo.Update(deleteCompanyQuery); err != nil {
		return nil, fmt.Errorf("failed to delete company %s: %w", id, err)
	}

	// remember ...
	g := ctx.Value("ginCtx").(*gin.Context)
	session, _ := r.Store.Get(g.Request, "user-session")
	sessInfo := session.Values[usersession.SessionInfoKey].(*usersession.UserSessionInfo)
	sessInfo.CompanyIds = slices.DeleteFunc(sessInfo.CompanyIds, func(toRemoveId string) bool { return toRemoveId == id })
	if err := session.Save(g.Request, g.Writer); err != nil {
		// Log or handle session save error if needed
		log.Printf("Error saving session: %v", err)
	}
	// If everything succeeds, return true

	success := true
	return &success, nil
}

// UpdateUserLookingForOpportunities is the resolver for the updateUserLookingForOpportunities field.
func (r *mutationResolver) UpdateUserLookingForOpportunities(ctx context.Context, userID string, looking bool) (*model.User, error) {
	// Convert the `looking` boolean to a string representation
	lookingStr := strconv.FormatBool(looking)

	// SPARQL update query to change the isLookingForOpportunities value
	q := fmt.Sprintf(`
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX schema: <http://schema.org/>
		PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

        DELETE {
            ?user lr:isLookingForOpportunities ?currentValue .
        }
        INSERT {
            ?user lr:isLookingForOpportunities "%s" .
        }
        WHERE {
            ?user a lr:User ;
            lr:Id "%s" ;
            lr:isLookingForOpportunities ?currentValue .
        }
    `, lookingStr, userID)

	err := r.UpdateRepo.Update(q)
	if err != nil {
		return nil, err
	}
	fmt.Println(err)

	// If the query was successful, return the updated user
	return loaders.GetUser(ctx, userID)
}

// AddEmployeesToCompany is the resolver for the addEmployeesToCompany field.
func (r *mutationResolver) AddEmployeesToCompany(ctx context.Context, companyID string, input model.EmployeeIds) ([]string, error) {
	if !slices.Contains(usersession.For(ctx).CompanyIds, companyID) {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update non owned company")
	}
	employeeTriples := ""
	for _, empID := range input.Ids {
		employeeTriples += fmt.Sprintf("lr:hasEmployee lr:User%s ; ", empID)
	}
	// Remove the last semicolon and space
	employeeTriples = strings.TrimSuffix(employeeTriples, "; ")

	update := fmt.Sprintf(`
	    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
	    PREFIX lr: <http://linkrec.example.org/schema#>
	    PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
	    INSERT DATA {
	        lr:Company%s %s .
	    }`, companyID, employeeTriples)

	err := r.UpdateRepo.Update(update)
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Could not add employees to company")
	}

	q := fmt.Sprintf(`
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX list: <http://jena.hpl.hp.com/ARQ/list#>
		SELECT 
			(GROUP_CONCAT(DISTINCT ?employeeId; separator=", ") AS ?employees)   
		WHERE {
			?company a lr:Company ;
				lr:Id "%s" .
		    OPTIONAL {
		        ?company lr:hasEmployee ?employee .
		        ?employee lr:Id ?employeeId .
		    }

		}
		GROUP BY ?company
	`, companyID)

	res, err := r.Repo.Query(q)

	if err != nil || len(res.Solutions()) == 0 {
		return nil, err
	}
	// returns only one so we index 0
	ids := strings.Split(res.Solutions()[0]["employees"].String(), ", ")
	return ids, nil
}

// RemoveEmployeesFromCompany is the resolver for the removeEmployeesFromCompany field.
func (r *mutationResolver) RemoveEmployeesFromCompany(ctx context.Context, companyID string, input model.EmployeeIds) ([]string, error) {
	if !slices.Contains(usersession.For(ctx).CompanyIds, companyID) {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update non owned company")
	}
	if !slices.Contains(usersession.For(ctx).CompanyIds, companyID) {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Can't update non owned company")
	}
	employeeTriples := ""
	for _, empID := range input.Ids {
		employeeTriples += fmt.Sprintf("lr:hasEmployee lr:User%s ; ", empID)
	}
	// Remove the last semicolon and space
	employeeTriples = strings.TrimSuffix(employeeTriples, "; ")

	update := fmt.Sprintf(`
	    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
	    PREFIX lr: <http://linkrec.example.org/schema#>
	    PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
	    DELETE DATA {
	        lr:Company%s %s .
	    }`, companyID, employeeTriples)

	err := r.UpdateRepo.Update(update)
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Could not add employees to company")
	}

	q := fmt.Sprintf(`
		PREFIX lr: <http://linkrec.example.org/schema#>
		PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
		PREFIX list: <http://jena.hpl.hp.com/ARQ/list#>
		SELECT 
			(GROUP_CONCAT(DISTINCT ?employeeId; separator=", ") AS ?employees)   
		WHERE {
			?company a lr:Company ;
				lr:Id "%s" .
		    OPTIONAL {
		        ?company lr:hasEmployee ?employee .
				?employee lr:Id ?employeeId .
		    }

		}
		GROUP BY ?company
	`, companyID)

	res, err := r.Repo.Query(q)

	if err != nil || len(res.Bindings()["employees"]) != 1 {
		return nil, err
	}
	// returns only one so we index 0
	ids := strings.Split(res.Bindings()["employees"][0].String(), ", ")
	return ids, nil
}

// ForUser is the resolver for the forUser field.
func (r *notificationResolver) ForUser(ctx context.Context, obj *model.Notification) (*model.User, error) {
	return loaders.GetUser(ctx, obj.ForUser.ID)
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	return loaders.GetUser(ctx, id)
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, name *string, location *string, isEmployer *bool, skills []string, lookingForOpportunities *bool) ([]*model.User, error) {
	// TODO: companies
	skill_ids := ""
	for _, skill := range skills {
		skill_ids += fmt.Sprintf(`lr:%s `, skill)
	}
	skill_filter := ""
	if skill_ids != "" {
		skill_filter = fmt.Sprintf("FILTER(?escoSkill IN (%s))", skill_ids)
	}

	name_filter := ""
	if name != nil {
		name_filter = fmt.Sprintf(`FILTER(?name = "%s")`, *name)
	}

	oppt_filter := ""
	if lookingForOpportunities != nil {
		oppt_filter = fmt.Sprintf("FILTER(?isLookingForOpportunities = %v)", *lookingForOpportunities)
	}

	qs := fmt.Sprintf(`
	PREFIX foaf: <http://xmlns.com/foaf/0.1/> 
	PREFIX lr: <http://linkrec.example.org/schema#>
	PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	PREFIX list: <http://jena.hpl.hp.com/ARQ/list#>
	PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
	PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
	PREFIX esco_skill: <http://data.europa.eu/esco/skill/>
	
	SELECT ?id ?name ?email ?locationId ?lookingForOpportunities 
		(GROUP_CONCAT(DISTINCT ?connectionName; separator=", ") AS ?connections) 
		(GROUP_CONCAT(DISTINCT ?educationEntry; separator=", ") AS ?educations)
		(GROUP_CONCAT(CONCAT(STRAFTER(STR(?escoSkill), STR(esco_skill:)), "|", ?skill); separator=",") as ?skillIdsAndLabels)
	WHERE {
		?user a lr:User ;
		lr:Id ?id ;
		foaf:name ?name ;
		foaf:mbox ?email ;
		lr:isLookingForOpportunities ?isLookingForOpportunities .
		OPTIONAL {
			?user foaf:based_near ?locationEntry .
			?locationEntry lr:Id ?locationId .
		}
		OPTIONAL {
			?user lr:hasSkill ?escoSkill .
			?escoSkill skos:prefLabel ?skill .
		}
		OPTIONAL {
			?user lr:hasConnection ?connection .
			?connection lr:Id ?connectionName .
		}
		OPTIONAL {
			?user lr:hasEducation ?education .
			?education lr:Id ?educationEntry .
		}
		BIND(?isLookingForOpportunities AS ?lookingForOpportunities)
		FILTER(LANG(?skill) = "en")
		%s
		%s
		%s

	}
	GROUP BY ?id ?name ?email ?locationId ?lookingForOpportunities`, name_filter, skill_filter, oppt_filter)
	res, err := r.Repo.Query(qs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	users := make([]*model.User, 0)
	for _, user := range res.Solutions() {
		obj, err := util.MapRdfUserToGQL(user)
		if err != nil {
			return nil, err
		}

		users = append(users, obj)
	}
	return users, nil
}

// GetUsersByID is the resolver for the getUsersById field.
func (r *queryResolver) GetUsersByID(ctx context.Context, ids []string) ([]*model.User, error) {
	return loaders.GetUsers(ctx, ids)
}

// GetVacancies is the resolver for the getVacancies field.
func (r *queryResolver) GetVacancies(ctx context.Context, title *string, location *string, requiredEducation *model.DegreeType, status *bool) ([]*model.Vacancy, error) {
	q := query_builder.
		QueryBuilder().Select([]string{"id", "title", "description", "location", "postedById", "startDate", "endDate", "status", "degreeType", "degreeField"}).
		GroupConcat("skill", ", ", "skills", true).
		WhereSubject("vacancy", "Vacancy").
		Where("Id", "id").
		Where("vacancyTitle", "title").
		Where("vacancyDescription", "description").
		Where("vacancyLocation", "location").
		Where("postedBy", "postedBy").
		Where("vacancyStartDate", "startDate").
		Where("vacancyEndDate", "endDate").
		Where("vacancyStatus", "status").
		Where("requiredDegreeType", "degreeType").
		Where("requiredDegreeField", "degreeField").
		Where("requiredSkill", "skill").
		WhereExtraction("postedBy", "Id", "postedById")
	if title != nil {
		q.Filter("name", []string{*title}, query_builder.EQ)
	}
	if location != nil {
		q.Filter("location", []string{*location}, query_builder.EQ)
	}
	if requiredEducation != nil {
		q.Filter("requiredEducation", []string{string(*requiredEducation)}, query_builder.EQ)
	}
	if status != nil {
		q.Filter("status", []string{strconv.FormatBool(*status)}, query_builder.EQ)
	}
	qs := q.GroupBy([]string{"id", "title", "description", "location", "postedById", "startDate", "endDate", "status", "degreeType", "degreeField"}).Build()

	fmt.Println(qs)
	res, err := r.Repo.Query(qs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	vacancies := make([]*model.Vacancy, 0)
	for _, user := range res.Solutions() {
		obj, err := util.MapRdfVacancyToGQL(user)
		if err != nil {
			return nil, err
		}
		vacancies = append(vacancies, obj)
	}
	return vacancies, nil
}

// GetVacancy is the resolver for the getVacancy field.
func (r *queryResolver) GetVacancy(ctx context.Context, id string) (*model.Vacancy, error) {
	return loaders.GetVacancy(ctx, id)
}

// GetCompanies is the resolver for the getCompanies field.
func (r *queryResolver) GetCompanies(ctx context.Context, name *string, location *string) ([]*model.Company, error) {
	q := query_builder.
		QueryBuilder().Select([]string{"id", "name", "email", "locationId"}).
		GroupConcat("vacancyId", ", ", "vacancies", true).
		GroupConcat("employeeId", ", ", "employees", true).
		WhereSubject("company", "Company").
		Where("Id", "id").
		Where("companyName", "name").
		Where("companyEmail", "email").
		NewOptional("company", "lr:companyLocation", "location").
		AddOptionalTriple("location", "lr:Id", "locationId").
		NewOptional("company", "lr:hasVacancy", "vacancy").
		AddOptionalTriple("vacancy", "lr:Id", "vacancyId").
		NewOptional("company", "lr:hasEmployee", "employee").
		AddOptionalTriple("employee", "lr:Id", "employeeId")
	if name != nil {
		q.Filter("name", []string{*name}, query_builder.EQ)
	}
	if location != nil {
		q.Filter("location", []string{*location}, query_builder.EQ)
	}
	qs := q.GroupBy([]string{"id", "name", "email", "locationId"}).Build()

	res, err := r.Repo.Query(qs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	companies := make([]*model.Company, 0)
	for _, company := range res.Solutions() {
		obj, err := util.MapRdfCompanyToGQL(company)
		if err != nil {
			return nil, err
		}
		companies = append(companies, obj)
	}
	return companies, nil
}

// GetCompany is the resolver for the getCompany field.
func (r *queryResolver) GetCompany(ctx context.Context, id string) (*model.Company, error) {
	return loaders.GetCompany(ctx, id)
}

// GetNotifications is the resolver for the getNotifications field.
func (r *queryResolver) GetNotifications(ctx context.Context, userID string) ([]*model.Notification, error) {
	q := query_builder.
		QueryBuilder().Select([]string{"id", "title", "message", "forUserId", "createdAt"}).
		WhereSubject("notification", "Notification").
		Where("Id", "id").
		Where("notificationTitle", "title").
		Where("notificationMessage", "message").
		Where("forUser", "forUser").
		NewOptional("notification", "lr:notificationCreatedAt", "createdAt").
		WhereExtraction("forUser", "Id", "forUserId")
	if userID != "" {
		quotedUserID := fmt.Sprintf("\"%s\"", userID)
		q.Filter("forUserId", []string{quotedUserID}, query_builder.EQ)
	}
	qs := q.GroupBy([]string{"id", "title", "message", "forUserId", "createdAt"}).Build()

	res, err := r.Repo.Query(qs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	notifications := make([]*model.Notification, 0)
	for _, notification := range res.Solutions() {
		obj, err := util.MapRdfNotificationToGQL(notification)
		if err != nil {
			return nil, err
		}
		notifications = append(notifications, obj)
	}
	return notifications, nil
}

// GetConnectionRequests is the resolver for the getConnectionRequests field.
func (r *queryResolver) GetConnectionRequests(ctx context.Context, userID string, status *bool) ([]*model.ConnectionRequest, error) {
	q := query_builder.
		QueryBuilder().Select([]string{"id", "fromUserId", "connectedToUserId", "status"}).
		WhereSubject("connectionRequest", "ConnectionRequest").
		Where("Id", "id").
		Where("fromUser", "user").
		Where("connectedToUser", "connectedTo").
		Where("requestStatus", "status").
		WhereExtraction("user", "Id", "fromUserId").
		WhereExtraction("connectedTo", "Id", "connectedToUserId")
	if userID != "" {
		quotedUserID := fmt.Sprintf("\"%s\"", userID)
		q.Filter("connectedToUserId", []string{quotedUserID}, query_builder.EQ)
	}
	if status != nil && userID != "" {
		q.AndFilter("status", []string{strconv.FormatBool(*status)}, query_builder.EQ)
	} else if status != nil {
		q.Filter("status", []string{strconv.FormatBool(*status)}, query_builder.EQ)
	}
	qs := q.GroupBy([]string{"id", "fromUserId", "connectedToUserId", "status"}).Build()

	res, err := r.Repo.Query(qs)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	connectionRequests := make([]*model.ConnectionRequest, 0)
	for _, connectionRequest := range res.Solutions() {
		obj, err := util.MapRdfConnectionRequestToGQL(connectionRequest)
		if err != nil {
			return nil, err
		}
		connectionRequests = append(connectionRequests, obj)
	}
	return connectionRequests, nil
}

// MatchVacancyToUsers is the resolver for the matchVacancyToUsers field.
func (r *queryResolver) MatchVacancyToUsers(ctx context.Context, vacancyID string, maxDist float64) ([]*model.User, error) {
	q := fmt.Sprintf(`
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX lr: <http://linkrec.example.org/schema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX list: <http://jena.hpl.hp.com/ARQ/list#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX lfn: <http://www.dotnetrdf.org/leviathan#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX esco: <http://data.europa.eu/esco/>
PREFIX schema: <http://schema.org/>

SELECT  DISTINCT ?userId (COALESCE(?sumRank, 0) AS ?rank) 
WHERE { 
  # constants 
  VALUES (?pi ?earthRadius) { (3.1415926535 6378.137) } 

  ?vacancy a lr:Vacancy ;
    	lr:Id "%s" ; 
        foaf:based_near ?vacancyLoc ; 
        lr:vacancyStatus true . 

  ?user a lr:User;
    	lr:Id ?userId ; 
        foaf:mbox ?userEmail ; 
        foaf:name ?userName ; 
        foaf:based_near ?userLoc ; 
        lr:isProfileComplete true ; 
        lr:isLookingForOpportunities true . 

  ?userLoc lr:longitude ?long1 ; 
           lr:latitude ?lat1 . 
  ?vacancyLoc lr:longitude ?long2 ; 
              lr:latitude ?lat2 . 

  # we create subqueries to handle no matches, that way we keep the user but have a count of 0
  OPTIONAL {
    SELECT ?user (COUNT(?matchedEducation) AS ?degreeMatchCount) WHERE { 
      ?vacancy lr:requiredDegreeType ?requiredDegreeType ; 
               lr:requiredDegreeField ?requiredDegreeField . 
      ?user lr:hasEducation ?matchedEducation . 
      ?matchedEducation lr:degreeType ?userDegreeType ; 
                        lr:degreeField ?userDegreeField . 
      ?userDegreeType rdfs:subClassOf* ?requiredDegreeType . 
      ?userDegreeField rdfs:subClassOf* ?requiredDegreeField . 
    } GROUP BY ?user
  }

  OPTIONAL {
    SELECT ?user (COUNT(?matchedExperience) AS ?experienceMatchCount)
    WHERE {
      ?vacancy lr:requiredExperience ?requiredExperience .
      ?requiredExperience lr:escoOccup ?requiredEscoId ;
                          lr:durationInMonths ?requiredDuration .

      ?user lr:hasExperience ?matchedExperience .
      ?matchedExperience lr:escoOccup ?requiredEscoId ;
                         lr:durationInMonths ?userDuration .

      FILTER(?userDuration >= ?requiredDuration)
    }
    GROUP BY ?user
  }

  OPTIONAL {
    SELECT ?user (COUNT(?matchedSkill) AS ?skillMatchCount)
    WHERE {
      ?vacancy lr:requiredSkill ?matchedSkill .
      ?user lr:hasSkill ?matchedSkill .
    }
    GROUP BY ?user
  }

  # haversine distance calculation 
  BIND(?earthRadius * 2 * lfn:sin-1(lfn:sqrt( 
        lfn:pow(lfn:sin((?lat2 - ?lat1) * ?pi / 360), 2) + 
        lfn:cos(?lat1 * ?pi / 180) * lfn:cos(?lat2 * ?pi / 180) * 
        lfn:pow(lfn:sin((?long2 - ?long1) * ?pi / 360), 2) 
      )) AS ?distanceInKm) 

    FILTER(?distanceInKm <= %f)

    # Compute total rank 
    BIND(COALESCE(?degreeMatchCount, 0) AS ?degreeMatch)
    BIND(COALESCE(?skillMatchCount, 0) AS ?skillMatch)
    BIND(COALESCE(?experienceMatchCount, 0) AS ?experienceMatch)
    BIND(?degreeMatch + ?skillMatch + ?experienceMatch as ?sumRank)
} 
GROUP BY ?userId ?sumRank
HAVING (?rank >= 0)
ORDER BY DESC(?rank)
LIMIT 50



	`, vacancyID, maxDist)

	res, _ := r.Repo.Query(q)
	userIds := res.Bindings()["userId"]
	var users = make([]*model.User, 0)
	if userIds != nil {
		ids := util.Map(userIds, func(u rdf.Term) string {
			return u.String()
		})
		users, _ = loaders.GetUsers(ctx, ids)
	}
	return users, nil
}

// MatchUserToVacancies is the resolver for the matchUserToVacancies field.
func (r *queryResolver) MatchUserToVacancies(ctx context.Context, userID string, maxDist float64, interval *model.DateInterval) ([]*model.Vacancy, error) {
	dateFilter := ""
	if interval != nil {
		start := time.Time(interval.Start)
		end := time.Time(interval.End)
		dateFilter = fmt.Sprintf(`FILTER(?startDate >= "%s" && ?endDate <= "%s")`, start.Format(time.DateOnly), end.Format(time.DateOnly))
	}
	q := fmt.Sprintf(`
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX lr: <http://linkrec.example.org/schema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX list: <http://jena.hpl.hp.com/ARQ/list#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX lfn: <http://www.dotnetrdf.org/leviathan#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX esco: <http://data.europa.eu/esco/>
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT DISTINCT ?vacancyId
    (COALESCE(?sumRank, 0) AS ?rank)
WHERE {

    VALUES (?pi ?earthRadius) { (3.1415926535 6378.137) }

    ?user a lr:User ;
    	lr:Id "%s" ;
        lr:isProfileComplete true ;
        lr:isLookingForOpportunities true ;
        foaf:based_near ?userLoc ;
        lr:hasSkill ?userSkill ;
        lr:hasEducation ?education .

    ?vacancy a lr:Vacancy ;
    	lr:Id ?vacancyId ;
     	lr:vacancyStartDate ?startDate;
     	lr:vacancyEndDate ?endDate ;
        foaf:based_near ?vacancyLoc ;
        lr:vacancyStatus true .
  

        %s
  	
  

    OPTIONAL {
        SELECT ?vacancy (COUNT(DISTINCT ?matchedSkill) AS ?skillMatchCount)
        WHERE {
            ?user lr:hasSkill ?matchedSkill .
      		?vacancy lr:requiredSkill ?matchedSkill
        }
        GROUP BY ?vacancy
    }

    OPTIONAL {
        SELECT ?vacancy (COUNT(DISTINCT ?userEducation) AS ?educationMatchCount)
        WHERE {
            ?user lr:hasEducation ?userEducation .
            ?userEducation lr:degreeType ?userDegreeType ;
                              lr:degreeField ?userDegreeField .


            ?vacancy lr:requiredDegreeType ?requiredDegreeType ;
                     lr:requiredDegreeField ?requiredDegreeField .

            ?userDegreeType rdfs:subClassOf* ?requiredDegreeType .
      		?userDegreeField rdfs:subClassOf* ?requiredDegreeField .
        }
        GROUP BY ?vacancy
    }

    OPTIONAL {
        SELECT ?vacancy (COUNT(DISTINCT ?matchedExperience) AS ?experienceMatchCount)
        WHERE {
            ?user lr:hasExperience ?userExperience .
            ?userExperience lr:escoOccup ?userEscoId ;
                             lr:durationInMonths ?userDuration .

            ?vacancy lr:requiredExperience ?matchedExperience .
            ?matchedExperience lr:escoOccup ?userEscoId ;
                               lr:durationInMonths ?requiredDuration .

            FILTER(?userDuration >= ?requiredDuration)
        }
        GROUP BY ?vacancy
    }

    ?userLoc lr:longitude ?long1 ;
             lr:latitude ?lat1 .
    ?vacancyLoc lr:longitude ?long2 ;
                lr:latitude ?lat2 .
    # Havrersine distance calculation
    BIND(?earthRadius * 2 * lfn:sin-1(lfn:sqrt(
        lfn:pow(lfn:sin((?lat2 - ?lat1) * ?pi / 360), 2) +
        lfn:cos(?lat1 * ?pi / 180) * lfn:cos(?lat2 * ?pi / 180) *
        lfn:pow(lfn:sin((?long2 - ?long1) * ?pi / 360), 2)
    )) AS ?distanceInKm)

	FILTER(?distanceInKm <= %f)


    BIND(COALESCE(?skillMatchCount, 0) AS ?skillMatch)
    BIND(COALESCE(?educationMatchCount, 0) AS ?educationMatch)
    BIND(COALESCE(?experienceMatchCount, 0) AS ?experienceMatch)

    BIND(?skillMatch + ?educationMatch + ?experienceMatch as ?sumRank)
  
}
GROUP BY ?vacancyId ?sumRank
HAVING (?rank >= 0)
ORDER BY DESC(?rank)
LIMIT 50
	`, userID, dateFilter, maxDist)

	res, _ := r.Repo.Query(q)
	fmt.Println(q)
	vacancyIds := res.Bindings()["vacancyId"]
	var vacancyResults = make([]*model.Vacancy, 0)
	if vacancyIds != nil {
		ids := util.Map(vacancyIds, func(u rdf.Term) string {
			return u.String()
		})
		vacancies, err := loaders.GetVacancies(ctx, ids)
		if err != nil {
			return nil, err
		}
		vacancyResults = vacancies
	}
	return vacancyResults, nil
}

// GetSkillsByName is the resolver for the getSkillsByName field.
func (r *queryResolver) GetSkillsByName(ctx context.Context, name string) ([]*model.Skill, error) {
	if len(name) < 3 {
		return []*model.Skill{}, nil
	}
	q := fmt.Sprintf(`
		PREFIX esco: <http://data.europa.eu/esco/model#>
		PREFIX esco_skill: <http://data.europa.eu/esco/skill/>
		PREFIX skos: <http://www.w3.org/2004/02/skos/core#>

		SELECT			
			?label ?id
		WHERE{
		  ?escoSkill a esco:Skill .
		  ?escoSkill skos:prefLabel ?label .
		  FILTER(LANG(?label) = "en" && regex(?label, ".*%s.*", "i"))
		  BIND(STRAFTER(STR(?escoSkill), STR(esco_skill:)) as ?id)
		}
		LIMIT 30
		
		`, name)
	res, err := r.Repo.Query(q)
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Error fetching skills")
	}

	skills, err := util.MapPrimitiveBindingsToStructArray[*model.Skill](res.Solutions())
	if err != nil {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Error fetching skills")
	}

	return skills, nil
}

// NewConnectionRequest is the resolver for the newConnectionRequest field.
func (r *subscriptionResolver) NewConnectionRequest(ctx context.Context, forUserID string) (<-chan *model.ConnectionRequest, error) {
	panic(fmt.Errorf("not implemented: NewConnectionRequest - newConnectionRequest"))
}

// ConnectionRequestStatusUpdate is the resolver for the connectionRequestStatusUpdate field.
func (r *subscriptionResolver) ConnectionRequestStatusUpdate(ctx context.Context, forUserID string) (<-chan *model.ConnectionRequest, error) {
	panic(fmt.Errorf("not implemented: ConnectionRequestStatusUpdate - connectionRequestStatusUpdate"))
}

// NewMatchingVacancy is the resolver for the newMatchingVacancy field.
func (r *subscriptionResolver) NewMatchingVacancy(ctx context.Context, userID string) (<-chan *model.Vacancy, error) {
	panic(fmt.Errorf("not implemented: NewMatchingVacancy - newMatchingVacancy"))
}

// NewNotification is the resolver for the newNotification field.
func (r *subscriptionResolver) NewNotification(ctx context.Context, forUserID string) (<-chan *model.Notification, error) {
	panic(fmt.Errorf("not implemented: NewNotification - newNotification"))
}

// Location is the resolver for the location field.
func (r *userResolver) Location(ctx context.Context, obj *model.User) (*model.Location, error) {
	if usersession.For(ctx).Id != obj.ID {
		return nil, gqlerror.ErrorPathf(graphql.GetPath(ctx), "Getting location of other user is not permitted")
	}
	return loaders.GetLocation(ctx, obj.Location.ID)
}

// Connections is the resolver for the connections field.
func (r *userResolver) Connections(ctx context.Context, obj *model.User) ([]*model.User, error) {
	ids := util.Map(obj.Connections, func(u *model.User) string {
		return u.ID
	})
	return loaders.GetUsers(ctx, ids)
}

// Education is the resolver for the education field.
func (r *userResolver) Education(ctx context.Context, obj *model.User) ([]*model.EducationEntry, error) {
	ids := util.Map(obj.Education, func(e *model.EducationEntry) string {
		return e.ID
	})
	return loaders.GetEducationEntries(ctx, ids)
}

// Companies is the resolver for the companies field.
func (r *userResolver) Companies(ctx context.Context, obj *model.User) ([]*model.Company, error) {
	ids := util.Map(obj.Companies, func(c *model.Company) string {
		return c.ID
	})
	return loaders.GetCompanies(ctx, ids)
}

// Location is the resolver for the location field.
func (r *vacancyResolver) Location(ctx context.Context, obj *model.Vacancy) (*model.Location, error) {
	return loaders.GetLocation(ctx, obj.Location.ID)
}

// PostedBy is the resolver for the postedBy field.
func (r *vacancyResolver) PostedBy(ctx context.Context, obj *model.Vacancy) (*model.Company, error) {
	return loaders.GetCompany(ctx, obj.PostedBy.ID)
}

// Company returns CompanyResolver implementation.
func (r *Resolver) Company() CompanyResolver { return &companyResolver{r} }

// ConnectionRequest returns ConnectionRequestResolver implementation.
func (r *Resolver) ConnectionRequest() ConnectionRequestResolver {
	return &connectionRequestResolver{r}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Notification returns NotificationResolver implementation.
func (r *Resolver) Notification() NotificationResolver { return &notificationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// Vacancy returns VacancyResolver implementation.
func (r *Resolver) Vacancy() VacancyResolver { return &vacancyResolver{r} }

type companyResolver struct{ *Resolver }
type connectionRequestResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type vacancyResolver struct{ *Resolver }
